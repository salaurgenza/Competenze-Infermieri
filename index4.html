<!doctype html>
<html lang="it" class="font-inter">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Valutazione Competenze</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Inter',sans-serif
        }

        .transition-all {
            transition: all .25s ease
        }

        /* Stile per il toggle (Tailwind-compatible) */
        .competence-toggle:checked + .block {
            background-color: #3b82f6; /* bg-blue-500 */
        }

        .competence-toggle:checked ~ .dot {
            transform: translateX(100%);
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 dark:bg-gray-900 dark:text-gray-100">
    <header class="bg-blue-700 text-white flex items-center justify-between px-6 py-4 shadow">
        <div class="flex items-center space-x-4">
            <h1 class="text-2xl font-semibold">Valutazione Competenze</h1>
            <span id="badgeReparto" class="text-sm px-2 py-1 bg-blue-800/30 rounded hidden"></span>
        </div>
        <div class="flex items-center gap-4">
            <button id="btnImport" class="text-sm bg-white/10 px-3 py-1 rounded hover:bg-white/20">VBHC</button>
            <button id="themeToggle" class="text-xl">🌙</button>
        </div>
    </header>

    <div class="flex min-h-[calc(100vh-64px)]">
        <aside class="w-64 bg-white dark:bg-gray-800 shadow-lg p-5 flex flex-col">
            <h2 class="text-lg font-semibold mb-4 text-blue-700 dark:text-blue-300">UNITA' OPERATIVE</h2>
            <nav class="space-y-3">
                <button class="reparto-btn flex items-center gap-3 w-full text-left px-3 py-2 rounded" data-reparto="Chirurgia Generale">🏥 <span>Chirurgie Generali</span></button>
                <button class="reparto-btn flex items-center gap-3 w-full text-left px-3 py-2 rounded hover:bg-gray-100 dark:hover:bg-gray-700" data-reparto="Chirurgie Specialistiche">⚕️ <span>Chirurgie Specialistiche</span></button>
                <button class="reparto-btn flex items-center gap-3 w-full text-left px-3 py-2 rounded hover:bg-gray-100 dark:hover:bg-gray-700" data-reparto="Day Surgery Oculistica">👁️ <span>Day Surgery Oculistica</span></button>
            </nav>

            <div class="mt-6">
                <button id="btnAddNurseLeft" class="w-full bg-green-600 text-white px-3 py-2 rounded mb-2">➕ Aggiungi infermiere</button>
                <button id="btnExportAll" class="w-full bg-gray-200 px-3 py-2 rounded mb-2">Esporta tutti (JSON)</button>
                <button id="btnClearAll" class="w-full bg-red-100 text-red-700 px-3 py-2 rounded">Svuota dati (test)</button>
            </div>
            <div class="space-x-3">
                <a href="report.html" class="bg-white/10 px-3 py-1 rounded">Report</a>
                <button id="clearLocal" class="bg-red-600 px-3 py-1 rounded text-white">Reset dati</button>
            </div>
            <div class="mt-auto text-xs text-center text-gray-500 dark:text-gray-400">© 2025 Valutazione Competenze – Sistema Formativo</div>
        </aside>

        <main class="flex-1 p-8 space-y-6 overflow-y-auto">
            <div class="flex items-center justify-between">
                <h2 class="text-2xl font-semibold text-blue-700 dark:text-blue-300">Scheda – <span id="currentReparto">Chirurgia Generale</span></h2>
                <div class="flex items-center gap-2">
                    <button id="btnStart" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Inizia valutazione</button>
                    <button id="btnSaveEval" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700">Salva valutazione</button>
                </div>
            </div>

            <div class="grid lg:grid-cols-3 gap-6">

                <section class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-md lg:col-span-1">
                    <div class="flex items-center justify-between mb-3">
                        <h3 class="text-lg font-semibold text-blue-700 dark:text-blue-300">Infermiere</h3>
                        <div class="flex gap-2">
                            <button id="btnEditNurse" class="hidden bg-yellow-500 text-white px-3 py-1 rounded">Modifica</button>
                            <button id="btnDeleteNurse" class="hidden bg-red-500 text-white px-3 py-1 rounded">Elimina</button>
                        </div>
                    </div>
                    <div id="nurseCard" class="text-sm text-gray-600 dark:text-gray-300">Nessun infermiere selezionato</div>
                </section>

                <section class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-md lg:row-span-2 lg:col-span-2">
                    <h3 class="text-lg font-semibold text-blue-700 dark:text-blue-300 mb-2">Competenze</h3>
                    <p id="instructions" class="text-sm text-gray-500 mb-4">Premi <b>Inizia valutazione</b> per abilitare le sezioni.</p>
                    <div id="competenceContainer" class="space-y-4 opacity-50 pointer-events-none max-h-[520px] overflow-y-auto"></div>

                    <div class="mt-4 border-t pt-3">
                        <p id="summaryLevel" class="text-lg font-semibold">-</p>
                        <p id="summaryScore" class="text-sm text-gray-500">Punteggio totale: 0</p>
                    </div>
                </section>

                <section class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-md lg:col-span-1">
                    <h3 class="text-lg font-semibold text-blue-700 dark:text-blue-300 mb-4">Grafico Radar</h3>
                    <canvas id="radarChart" class="w-full h-64"></canvas>
                    <div class="mt-4 space-y-2">
                        <button id="btnExportJSON" class="w-full bg-gray-200 dark:bg-gray-700 px-3 py-2 rounded">Esporta valutazione (JSON)</button>
                    </div>
                </section>
            </div>

            <section class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-md">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-lg font-semibold text-blue-700 dark:text-blue-300">Elenco Infermieri</h3>
                    <div class="text-sm text-gray-500">Seleziona per modificare o valutare</div>
                </div>
                <div id="nursesList" class="grid sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3"></div>
            </section>
        </main>
    </div>

    <div id="modalNurse" class="fixed inset-0 bg-black bg-opacity-40 hidden items-center justify-center z-50">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg w-96 shadow-lg">
            <h3 id="modalTitle" class="text-xl font-semibold mb-4 text-blue-700 dark:text-blue-300">
                Aggiungi Infermiere
            </h3>

            <div class="space-y-2">
                <input id="inputNome" class="w-full p-2 border rounded" placeholder="Nome">
                <input id="inputCognome" class="w-full p-2 border rounded" placeholder="Cognome">
                <input id="inputEsperienza" type="number" min="0" class="w-full p-2 border rounded" placeholder="Esperienza (anni)">
                <input id="inputMatricola" class="w-full p-2 border rounded" placeholder="Matricola">
                <input id="inputRuolo" class="w-full p-2 border rounded" placeholder="Ruolo">
                <input id="inputReparto" class="w-full p-2 border rounded" placeholder="Reparto">
                <input id="inputValutatore" class="w-full p-2 border rounded" placeholder="Valutatore">
            </div>

            <div class="mt-5 flex justify-end gap-2">
                <button id="modalCancel" class="px-3 py-2 bg-gray-200 hover:bg-gray-300 rounded">
                    Annulla
                </button>
                <button id="modalSave" class="px-3 py-2 bg-green-600 hover:bg-green-700 text-white rounded">
                    Salva
                </button>
            </div>
        </div>
    </div>
    <div id="competenceModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center hidden">
        <div class="bg-white dark:bg-gray-800 rounded-xl shadow-2xl w-full max-w-3xl max-h-[90vh] flex flex-col overflow-hidden transform transition-all duration-300 scale-95 opacity-0" id="modalContentContainer">

            <div class="p-6 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center sticky top-0 bg-white dark:bg-gray-800 z-10">
                <h2 id="modalTitle" class="text-xl font-bold text-blue-700 dark:text-blue-300">Valutazione Dettagliata</h2>
                <button onclick="closeModal()" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>

            <div id="modalBody" class="p-6 overflow-y-auto flex-grow">
                <p class="text-gray-500">Caricamento...</p>
            </div>

            <div class="p-4 border-t border-gray-200 dark:border-gray-700 sticky bottom-0 bg-white dark:bg-gray-800 z-10 text-right">
                <button onclick="closeModal()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition-colors shadow-md">
                    Chiudi e Salva Punteggi
                </button>
            </div>

        </div>
    </div>

    <script>// === FUNZIONI BACKEND FLASK / SQLITE ===
        async function salvaInfermieriNelDB(infermiere) {
            try {
                const res = await fetch("/api/inserisci_infermiere", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(infermiere)
                });
                console.log("Infermiere salvato su DB:", await res.json());
            } catch (e) {
                console.error("Errore salvataggio infermiere su DB:", e);
            }
        }

        async function salvaValutazioneNelDB(valutazione) {
            try {
                const res = await fetch("/api/inserisci_valutazione", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(valutazione)
                });
                console.log("Valutazione salvata su DB:", await res.json());
            } catch (e) {
                console.error("Errore salvataggio valutazione su DB:", e);
            }
        }


        // ---------- Utility & Data ----------
        function uid() {
            return 'n_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
        }

        const STORAGE_KEY = 'valutazioni_dashboard_v2';

        // Mappatura fissa dei livelli (USATA PER LA VISUALIZZAZIONE E IL SALVATAGGIO)

        const LEVEL_MAP = {
            1: '1 - Supervisione Diretta',
            2: '2 - Supervisione Indiretta',
            3: '3 - Professionista Autonomo',
            4: '4 - Autonomo e Formatore'
        };

        // Funzione per convertire il punteggio (o la media) nel testo del livello
        function scoreToLevelText(score) {
            // Arrotonda per eccesso per decidere il livello (es. 2.1 -> 3)
            const level = Math.ceil(score);
            // Assicura che il livello sia tra 1 e 4
            const clampedLevel = Math.min(4, Math.max(1, level));
            return LEVEL_MAP[clampedLevel] || 'Livello non definito';
        }


        // STRUTTURA DATI AGGIORNATA: Mappa le competenze per reparto
        const COMPETENCE_DATA = {
            "Chirurgia Generale": [
                {
                    key: 'Chirurgia Addominale',
                    questions: [
                        'LAPAROTOMIA ESPLORATIVA, ERNIOPLASTICA INGUINALE, ERNIOPLASTICA OMBELICALE, PLASTICA DI PARETE CON PROTESI',
                        'LAPAROSCOPIA ESPLORATIVA, ERNIOPLASTICA INGUINALE, COLECISTECTOMIA, APPENDICECTOMIA, LPS DIAGNOSTICA CON O SENZA PIPAC, LPS DIAGNOSTICA CON O SENZA BIOPSIE',
                        'CONFEZIONAMENTO ILEOSTOMIA, CONFEZIONAMENTO COLONSTOMIA, CONFEZIONAMENTO DIGIUNOSTOMIA, CHIUSURA ILEOSTOMIA, CHIUSURA COLONSTOMIA, RIPARAZIONE ERNIA IATALE',
                        'APPENDICECTOMIA LAPAROTOMICA, COLECISTECTOMIA LAPAROTOMICA',
                        'APPENDICECTOMIA LAPAROSCOPICA, COLECISTECTOMIA LAPAROSCOPICA',
                        'FUNDOPLICATIO ROBOT ASSISTITA',
                        'AMPUTAZIONE ADDOMINO - PERINEALE SEC MILES LAPAROTOMICA, ANASTOMOSI ILEO COLICA LAPAROTOMICA, ANASTOMOSI COLO COLICA LAPAROTOMICA, EMICOLECTOMIA DX LAPAROTOMICA, EMICOLECTOMIA SIN LAPAROTOMICA, RESEZIONE ANTERIORE DEL RETTO LAPAROTOMICA, RESEZIONE SEGMENTARIA MULTIPLA INTESTINALE LAPAROTOMICA, RESEZIONE DEL SIGMA LAPAROTOMICA, RESEZIONE TENUALE LAPAROTOMICA, RICANALIZZAZIONE COLO - RETTALE POST HARTAMANN SENZA RESEZIONE LAPAROTOMICA, RESEZIONE ILEALE LAPAROTOMICA, RESEZIONE COLON TRASVERSO LAPAROTOMICA, RESEZIONE DEL SIGMA RETTO LAPAROTOMICA, GASTRECTOMIA SUBTOTALE / TOTALE LAPAROTOMICA',
                        'AMPUTAZIONE ADDOMINO - PERINEALE SEC MILES LPS, ANASTOMOSI ILEO COLICA LPS, ANASTOMOSI COLO COLICA LPS, EMICOLECTOMIA DX LPS, EMICOLECTOMIA SIN LPS, RESEZIONE ANTERIORE DEL RETTO, RESEZIONE SEGMENTARIA MULTIPLA INTESTINALE, RESEZIONE DEL SIGMA LPS, RESEZIONE TENUALE LPS, RICANALIZZAZIONE COLO - RETTALE POST HARTAMANN SENZA RESEZIONE LPS, RESEZIONE ILEALE LPS, RESEZIONE COLON TRASVERSO LPS, RESEZIONE DEL SIGMA RETTO LPS, GASTRECTOMIA SUBTOTALE / TOTALE LPS',
                        'RESEZIONE ANTERIORE DEL RETTO ROBOT ASSISTITA, SPLENOPANCREASECTOMIA DISTALE ROBOT ASSISTITA, EMICOLECTOMIA DX ROBOT ASSISTITA, EMICOLECTOMIA SIN ROBOT ASSISTITA',
                        'SPLENECTOMIA, SPLENOPANCREASECTOMIA DISTALE LAPAROTOMICA',
                        'SPLENECTOMIA, SPLENOPANCREASECTOMIA DISTALE LAPAROSCOPICA',
                        'SPLENOPANCREASECTOMIA DISTALE ROBOT ASSISTITA',
                        'PERITONECTOMIA SELETTIVA CON O SENZA HIPEC, CITORIDUZIONE CON O SENZA HIPEC',
                        'TATME (TRANSANAL TOTAL MESORECTAL EXCISION) LAPAROSCOPICO',
                        'DUODENOCEFALOPANCREASECTOMIA',
                        'DUODENOCEFALOPANCREASECTOMIA ROBOT ASSISTITA',
                        'ESOFAGECTOMIA'
                    ]
                },
                {
                    key: 'Chirurgia Vascolare',
                    questions: [
                        'LEGATURA E STRIPPING DI VENE DELL’ARTO INFERIORE',
                        'AMPUTAZIONE RAGGIO DEL PIEDE, AMPUTAZIONE SOTTO IL GINOCCHIO',
                        'ENDOARTERIECTOMIA DELLA BIFORCAZIONE CAROTIDEA, ASPORTAZIONE DI PARAGANGLIOMA CAROTIDEO, ENDOARTERIECTOMIA DEL TRIPODE FEMORALE',
                        'ANGIOPLASTICA ARTERIA FEMORALE, ANGIOPLASTICA ARTERIA ILIACA, ANGIOPLASTICA ARTERIA POPLITEA, ANGIOPLASTICA ARTERIA SUCCLAVIA, ANGIOPLASTICA CAROTIDEA CON INSERIZIONE DI STENT, ANGIOPLASTICA E STENT ARTERIA FEMORALE, ANGIOPLASTICA E STENT ARTERIA ILIACA, ANGIOPLASTICA E STENT ARTERIA POPLITEA, ANGIOPLASTICA E STENT IN VASO PERIFERICO, ANGIOPLASTICA VASI ADDOMINALI, ARTERIOGRAFIA, ESCLUSIONE ENDOVASCOLARE DELL’AORTA TORACICA, ESCLUSIONE ENDOVASCOLARE DELL’ARCO AORTICO, ESCLUSIONE ENDOVASCOLARE DI ANEURISMA DELL’AORTA ADDOMINALE SOTTORENALE, ESCLUSIONE ENDOVASCOLARE DI ANEURISMA DELL’AORTA ADDOMINALE SOPRARENALE',
                        'BY PASS AORTO RENALE, INNESTO AORTO BISILIACO, BY PASS AORTO - ILIACO BIFEMORALE, INNESTO AORTO AORTICO SOPRARENALE CON PERFUSIONE IPOTERMICA ARTERIE RENALI, BY PASS FEMORO FEMORALE, BY PASS AXILLO BIFEMORALE, BYPASS AORTO - ILIACO MESENTERICO, BY PASS FEMORO POPLITEO SOTTOGENICOLARE IN SAFENA, RESEZIONE VASCOLARE ADDOMINALE ARTERIOSA, BY PASS CAROTIDEO SUCCLAVIO, BY PASS FEMORO POPLITEO SOTTOGENICOLARE IN PROTESI, BY PASS AORTO ILIACO BIFEMORALE, INNESTO AORTO BISILIACO',
                        'INNESTO AORTO AORTICO TORACO - ADDOMINALE'
                    ]
                },
                {
                    key: 'Chirurgia Endocrino e Metabolica',
                    questions: [
                        'LOBOISTMECTOMIA TIROIDEA, TIROIDECTOMIA TOTALE, TIROIDECTOMIA TOTALE + LINFOADENECTOMIA DEL COMPARTIMENTO CENTRALE, PARATIROIDECTOMIAEMI, TIROIDECTOMIA TOTALE + LINFOADENECTOMIA LATERO CERVICALE',
                        'TIROIDECTOMIA ROBOT ASSISTITA',
                        'SLEEVE GASTRECTOMY LAPAROTOMICA, SADIS LAPAROTOMICA, BYPASS GASTRICO LAPAROTOMICO',
                        'SLEEVE GASTRECTOMY LPS, SADIS LPS, BYPASS GASTRICO LPS, MINI - BYPASS GASTRICO LPS, REVISIONE DI DIVERSIONE BILIO - PANCREATICA LPS',
                        'SLEEVE GASTRECTOMY ROBOT ASSISTITA, SADIS ROBOT ASSISTITA, BYPASS GASTRICO ROBOT ASSISTITA',
                        'SURRENECTOMIA LAPAROTOMICA',
                        'SURRENECTOMIA ROBOT ASSISTITA'
                    ]
                },
                {
                    key: 'Chirurgia EpatoBiliare',
                    questions: [
                        'FENESTRAZIONE DI CISTI EPATICA LPS',
                        'RESEZIONI EPATICHE LIMITATE LPT, SEGMENTECTOMIA EPATICA / BISEGMENTECTOMIA EPATICA ANATOMICHE SETTORIALI LPT',
                        'RESEZIONI EPATICHE LIMITATE LPS, SEGMENTECTOMIA EPATICA / BISEGMENTECTOMIA EPATICA ANATOMICHE SETTORIALI LPS',
                        'RESEZIONI EPATICHE LIMITATE ROBOT ASSISTITA, SEGMENTECTOMIA EPATICA / BISEGMENTECTOMIA EPATICA ANATOMICHE SETTORIALI ROBOT ASSISTITA',
                        'EPATETOMIA SINISTRA / DX LPT, MESOEPATECTOMIA LPT, TWO STAGE EPATECTOMY LPT, ALPPS LPT',
                        'EPATETOMIA SINISTRA / DX LPS, MESOEPATECTOMIA LPS, TWO STAGE EPATECTOMY LPS, ALPPS LPS',
                        'EPATETOMIA SINISTRA / DX ROBOT ASSISTITA, MESOEPATECTOMIA ROBOT ASSISTITA'
                    ]
                },
                {
                    key: 'Chirurgia Toracica',
                    questions: [
                        'TORACOTOMIA ESPLORATIVA, BIOPSIE PLEURICHE, BIOPSIE LINFONODALI, PLASTICA DI ERNIA DIAFRAMMATICA, ASPORTAZIONE DI LESIONE DELLA PARETE TORACICA',
                        'SIMPATICOFRASSI, TORACOSCOPIA ESPLORATIVA, BIOPSIE PLEURICHE TORACOSCOPICHE',
                        'RESEZIONE POLMONARE ATIPICA TORACOTOMICA, LOBECTOMIA POLMONARE TORACOTOMICA, BILOBECTOMIA POLMONARE TORACOTOMICA, APICECTOMIA POLMONARE TORACOTOMICA, SEGMENTECTOMIA POLMONARE TORACOTOMICA, PNEUMECTOMIA TORACOTOMICA',
                        'RESEZIONE POLMONARE ATIPICA TORACOSCOPICA, LOBECTOMIA POLMONARE TORACOSCOPICA, BILOBECTOMIA POLMONARE TORACOSCOPICA, APICECTOMIA POLMONARE TORACOSCOPICA, SEGMENTECTOMIA POLMONARE TORACOSCOPICA',
                        'SEGMENTECTOMIA / LOBECTOMIA POLMONARE ROBOT ASSISTITA',
                        'TIMECTOMIA STERNOTOMICA',
                        'TIMECTOMIA ROBOT ASSISTITA'
                    ]
                },
                {
                    key: 'Chirurgia Trapianti',
                    questions: [
                        'TX DI RENE DA VIVENTE / MORTE',
                        'TX DI FEGATO'
                    ]
                },
                {
                    key: 'Chirurgia Urologia',
                    questions: [
                        'TURV, TURP',
                        'URETEROSCOPIA (RIRS, ULT, PCNL)',
                        'ASPORTAZIONE IDROCELE, ASPORTAZIONE O DEMOLIZIONE DI LESIONE DEL PENE, BIOPSIA PENE, BIOPSIA PROSTATICA, CATETERIZZAZIONE URETERALE, CIRCONCISIONE, CORPOROPLASTICA PENIENA, INCISIONE E DRENAGGIO SCROTO E TUNICA VAGINALE, BIOPSIA TRANSPERINEALE DELLA PROSTATA, ORCHIECTOMIA MONOLATERALE / BILATERALE',
                        'PIELOPLASTICA, REIMPIANTO URETERE ACQUISITO, RESEZIONE TRANSURETRALE LESIONE VESCICALE O NEOPLASIA, SOSPENSIONE URETRALE SOVRAPUBICA CON SLING',
                        'CISTECTOMIA LAPAROTOMICA',
                        'NEFRECTOMIA PARZIALE / RADICALE LAPAROTOMICA, ENUCLEORESEZIONE RENALE LAPAROTOMICA',
                        'NEFRECTOMIA PARZIALE / RADICALE LPS, ENUCLEORESEZIONE RENALE LPS, NEFROURETERECTOMIA LPS',
                        'NEFRECTOMIA PARZIALE / RADICALE ROBOT ASSISTITA, ENUCLEORESEZIONE RENALE ROBOT ASSISTITA, NEFROURETERECTOMIA ROBOT ASSISTITA',
                        'PROSTATECTOMIA LAPAROTOMICA',
                        'PROSTATECTOMIA ROBOT ASSISTITA'
                    ]
                },
                {
                    key: 'Chirurgia Pediatrica',
                    questions: [
                        'CHIUSURA DI COLOSTOMIA CON RESEZIONE E ANASTOMOSI, CHIUSURA DI ILEOSTOMIA CON RESEZIONE E ANASTOMOSI',
                        'LPS ESPLORATIVA, APPENDICECTOMIA LAPAROSCOPICA',
                        'PLASTICA DI ERNIA INGUINALE, CHIUSURA DEL DOTTO PERITONEO - VAGINALE, CIRCONCISIONE, ASPORTAZIONE DI IDROCELE, ASPORTAZIONE DI VARICOCELE, ORCHIOPESSI MONOLATERALE / BILATERALE, RIPARAZIONE DI IPOSPADIA, BIOPSIA DI LINFONODI',
                        'CISTOSCOPIA, PIELOPLASTICA, CHIUSURA DI FISTOLA URETRALE',
                        'ESOFAGO - ESOFAGOSTOMIA INTRATORACICA'
                    ]
                }
            ],


            "Chirurgie Specialistiche": [
                {
                    key: 'Ch. Senologica', questions: [
                        'Biopsia del linfonodo sentinella, escissione nodulo mammario, quadrantectomia mammaria',
                        'Mastectomia semplice/radicale monolaterale/bilaterale, linfoadenectomia ascellare monolaterale/bilaterale',
                        'Quadrantectomia mammaria con mastoplastica riduttiva, mastectomia nipple sparing or skin sparing/reducing monolaterale/bilaterale'
                    ]
                },
                {
                    key: 'Ch. plastica', questions: [
                        'Asportazione radicale di lesione della cute, allargamento cicatrice chirurgia pregresso melanoma e biopsia del linfonodo sentinella',
                        'Liposuzione in esiti chirurgia bariatrica e della mammella, lifting braccia-addome e cosce, rimozione protesi della mammella, inserzione di espansore tissutale della mammella mono/bilaterale',
                        'Asportazione neoformazioni cutanee estese con innesto lembo di scorrimento',
                        'Mastopessi/mastoplastica riduttiva mono-bilaterale, ricostruzione mammaria con protesi mono/bilaterale',
                        'Anastomosi venolinfatiche per linfedema arto inferiore/superiore, lembo microchirurgico/peduncolato per ricostruzione mammaria, ricostruzione con innesto cutaneo/lembo locale a distanza-microvascolare del perineo e della vulva'
                    ]
                },
                {
                    key: 'Ortopedia e Traumatologia',
                    questions: [
                        'CHIRURGIA OMERO frattura, pseudoartrosi, neoformazione, infezioni osteo-articolari: sintesi percutanea con fissatore esterno, sintesi con placca e viti/chiodo endomidollare, osteotomia, rimozione mezzi di sintesi, biopsia percutanea/open e asportazione neoformazioni muscolo-scheletriche, innesti ossei, amputazione, impianto spaziatore',
                        'CHIRURGIA RADIO/ULNA (frattura, pseudoartrosi, neoformazione, lussazione): sintesi percutanea con fissatore esterno, sintesi con placca e viti/chiodo endomidollare, osteotomia, rimozione mezzi di sintesi, biopsia percutanea/open e asportazione neoformazioni muscolo-scheletriche, innesti ossei, amputazione, riduzione incruenta',
                        'CHIRURGIA GOMITO (frattura, lussazione): artrolisi artroscopica, sintesi, protesi totale',
                        'CHIRURGIA MANO/PIEDE (frattura, neoformazione, lussazione): amputazione, correzione dita, rimozione mezzi di sintesi, biopsia e asportazione neoformazione, revisione, sintesi con placche e viti/fili di k, osteotomia, rimozione corpi estranei, innesti ossei, neurolisi e tenolisi.',
                        'CHIRURGIA SPALLA Endoprotesi e artroprotesi totale, artroscopia per sinovialectomia -artrolisi-lesione cuffie rotatori',
                        'CHIRURGIA SCAPOLA/CLAVICOLA sintesi con placca e viti, biopsia, rimozione mezzi di sintesi, osteotomia',
                        'CHIRURGIA COSTE/STERNO biopsia open/percutanea',
                        'CHIRURGIA BACINO sintesi percutanea e/o con fissatore esterno, sintesi con placche e viti, biopsia open/percutanea, rimozione mezzi di sintesi',
                        'CHIRURGIA ANCA (frattura, coxartrosi, lussazione, neoformazione): endoprotesi, artroprotesi totale, innesti ossei, revisione, impianto e rimozione spaziatore',
                        'CHIRURGIA FEMORE (frattura, neoformazione, infezione): sintesi con placca e viti/ chiodo endomidollare, sintesi percutanea con fissatore esterno, rimozione mezzi di sintesi, innesti ossei, impianto e rimozione spaziatore, allungamento',
                        'CHIRURGIA GINOCCHIO riduzione incruenta, protesi totale/gonartrosi primaria e secondaria, artroscopia per artrolisi-sinovialectomia-sutura meniscale-meniscectomia, rimozione e impianto spaziatore, revisione, amputazione, ricostruzione legamento crociato anteriore, artroscopia/open del legamento collaterale del ginocchio e crociato anteriore.',
                        'CHIRURGIA TIBIA/PERONE (frattura, pseudoartrosi, neoformazioni, infezioni osteo-articolari) allungamento con innesto osseo/fissatore esterno, sintesi con placca e viti/chiodo endomidollare, sintesi percutanea con fissatore esterno, biopsia percutanea/open, osteotomia, rimozione mezzi di sintesi, innesti ossei, toilette chirurgica, impianto e rimozione spaziatore',
                        'CHIRURGIA TESSUTI MOLLI/TENDINI E ARTICOLAZIONI fasciotomia per sdr compartimentale, riparazione e innesti tendinei e della cartilagine articolare, tenorrafia, decompressione, toilette ferita chirurgica',
                    ]
                },
                {
                    key: 'Chirurgia Vertebrale',
                    questions: [
                        'CHIRURGIA VERTEBRALE BASE biopsia percutanea/open, cifoplastica vertebroplastica, microdiscectomia',
                        'CHIRURGIA VERTEBRALE MEDIA decompressione del canale vertebrale/radicolare, rimozione di mezzi di sintesi, trazione cervicale con applicazione di Halo',
                        'CHIRURGIA VERTEBRALE ELEVATA artrodesi: cervicale anteriore/posteriore, dorsale e dorso-lombare con/senza cage open/percutaneo, lombare anterolaterale (XLIF) e posteriore open/percutaneo, lombare anteriore (ALIF) e posteriore percutanea/open',
                    ]
                },
                {
                    key: 'Neurochirurgia',
                    questions: [
                        'CHIRURGIA DELL/IDROCEFALO: derivazioni lombo-peritoneali, ventricolo-atriali, ventricolo-peritoneali, derivazione ventricolare esterna',
                        'REVISIONE E RIMOZIONE SISTEMA DI DERIVAZIONE LIQUORALE: VENTRICOLO-PERITONEALE, SPINO-PERITONEALE.',
                        'CHIRURGIA ENDOSCOPICA CEREBRALE: TERZOVENTRICOLOSTOMIA ENDOSCOPICA, VENTRICOLOSTOMIA ENDOSCOPICA.',
                        'CHIRURGIA TRAUMATOLOGICA: EVACUAZIONE MONOLATERALE E BILATERALE DI EMATOMA SOTTODURALE, EMATOMA SUBDURALE, CRANIOTOMIA CON EVACUAZIONE DI EMATOMA SOTTODURALE.',
                        'INTERVENTI CHIRURGICI SU LESIONI DELLA BASE CRANICA: ASPORTAZIONE LESIONE SELLARE PER VIA ENDOSCOPICA, RIPARAZIONE FISTOLA LIQUORALE PER VIA TRASFENOIDALE ENDOSCOPICA',
                        'CHIRURGIA DEI NERVI PERIFERICI: NEUROLISI TUNNEL CARPALE, NEUROLISI TUNNEL CUBITALE.',
                        'NEUROCHIRURGIA FUNZIONALE: DEEP BRAIN STIMULATION (DBS)',
                        'NEUROCHIRURGIA FUNZIONALE: IMPIANTO/REVISIONE/SOSTITUZIONE ELETTRODO E GENERATORE PER STIMOLAZIONE NERVO VAGO.',
                        'NEUROCHIRURGIA FUNZIONALE: IMPIANTO/REVISIONE/SOSTITUZIONE ELETTRODO E GENERATORE PER STIMOLAZIONE MIDOLLARE (SCS).',
                        'NEUROCHIRURGIA FUNZIONALE: IMPIANTO DI SISTEMA DI INFUSIONE INTRATECALE.',
                        'INTERVENTI CHIRURGICI SULLA COLONNA VERTEBRALE: ERNIE DISCALI LOMBARI-CERVICALI, STENOSI DELLA COLONNA CERVICALE-LOMBARE, STABILIZZAZIONI.',
                        'INTERVENTI CHIRURGICI CRANICI MAGGIORI: TUMORALI, VASCOLARI, TRAUMATICI, MALFORMATIVI.',
                        'CHIRURGIA VASCOLARE CEREBRALE: CLIPPING DI ANEURISMA CEREBRALE, MALFORMAZIONI ARTERO-VENOSE (MAV)',
                        'CHIRURGIA DELLA RIVASCOLARIZZAZIONE CEREBRALE: BYPASS CEREBRALE EXTRACRANICO-INTRACRANICO',
                        'CRANIOPLASTICA: CUSTOM MADE, OSSO AUTOLOGO',
                        'INTERVENTI CHIRURGICI PER NEVRALGIA TRIGEMINALE: COMPRESSIONE PERCUTANEA CON PALLONCINO DEL GANGLIO DEL GASSER, DECOMPRESSIONE TRIGEMINALE CON CRANIOTOMIA',
                        'INTERVENTO CHIRURGICO PER CORREZIONE MALFORMAZIONE DI CHIARI OSSO E OSSO-TONSILLE CEREBELLARI (NEUROCHIRURGIA INFANTILE)',
                        'CRANIOPLASTICA ESPANSIVA-RICOSTRUTTIVA: BIPARIETALE, OCCIPITALE, FRONTO-ORBITARIA (NEUROCHIRURGIA INFANTILE)'
                    ]
                },
                {
                    key: 'Otorinolaringoiatria',
                    questions: [
                        'CAVO ORALE: adenotonsillectomia, aportazione neoformazione labbro, guancia, lingua e faringea. Uvulofaringopalatoplastica, asportazione corpo estraneo faringeo e laringeo, incisione ascesso tonsillare, marsupializzazione del dotto salivare e dell/ascesso parotideo. Scialoendoscopia, frenuloplastic linguale, riparazione fistola oroantrale e oronasale, asportazione neoformazione del palato duro ,asporazione di ranula sotto liguale e gengivale. MicroLaringoscopia ',
                        'NASO: RIMOZIONE CORPO ESTRANEO NARICE, RINOFARINGEO E DEL SENO MASCELLARE. SETTOPLASTICA, RINOSETTOPLASTICA, RIMOZIONE DI POLIPI ANTROCOANALE, TURBINECTOMIA E TURBINOTOMIA, EMOSTASI VARISI NASALI, EXENTERATIO ORBITARIE, CHIRURGIA DEI SENI PARANASALI E DELL’ORBITA PER VIA ENDOSCOPICA, FRATTURA OSSA NASALI, ATRESIA COANALE, DACRIOCISTORINOSTOMIA.',
                        'ORECCHIO: CHIUSURA FISTOLA OTO-LIQUORALE, MASTOIDECTOMIA, EXERESI COLESTEATOMA DELLA ROCCA, ATRESIA AURIS, LABIRINTECTOMIA, MEATOPLASTICA, MIRINGOPLASTICA, MIRINGOTOMIA, OSSICULOPLASTICA, TIMPANOPLASTICA DI TIPO I II III IV, RIMOZIONE CORPO ESTRANEO, STENOSI DEL CONDOTTO URICOLARE, TIMPANOPLASTICA, ASPORTAZIONE NEOFORMAZIONEE PADIGLIONE AURICOLARE.',
                        'ORECCHIO AVANZATO: TIMPAMOPLASTICA DI TIPO V, PETROSECTOMIA, ASPORTAZIONE DI NEURINOMA DELL’ACUSTICO E ANGOLO PONTECEREBELLARE, IMPIANTO COCLEARE.',
                        'COLLO: SVUOTAMENTO LATERO CERVICALE, ASPORATAZIONE DI NEOFORMZIONE ESTERNA DELLA CUTE, CERVICOTOMIA, PAROTIDECTOMIA, SCIALECTOMIA, INCISIONE E DRENAGGIO DI ASCESSO-FLEMMONE LATEROCERVICALE, LARINGECTOMIA PARZIALE E TOTALE, RICOSTRUZIONE DEL NERVO FACCIALE, TRACHEOTOMIA.',
                        'GLOMO: CAROTIDEO, TIMPANICO - TIMPANICOGIUGULARE, LINFANGIOMA DEL COLLO, PARAGANGLIOMA CAROTIDEO. CONTROLLO EMOSTASI TONSILLARE.',
                        'LEMBO: ASPORTAZIONE DEL LABBRO, DELLA GUANCIA, GLOSSECTOMIA CON RICOSTRUZIONE LEMBO LIBERO PEDUNCOLATO, PETTORALE E DEL MASSICCIO FACCIALE. MANDIBULECTOMIA CON RICOSTRUZIONE OSSO AUTOLOGO.',
                        'LEMBO CON TECNICA DI LABBE’.',
                        'OTOSCLEROSI, CORDECTOMIA E EMILARINGECTOMIA SOVRAGLOTTICA CON LASER AD ANIDRIDE CARBONICA.'
                    ]
                },
                {
                    key: 'Maxillo-Facciale',
                    questions: [
                        'CAVO ORALE:asportazione neoformazione lingua, palato duro, osteolitica mascellare, guancia e labbra. Fistola oro-nasoantrale',
                        'MASCELLA: FRATTURA LE FORT I II III, MASCELLARE CON MEZZI DI SINTESI E CONDILO MANDIBOLARE. GENIOPLASTICA. CORREZIONE PROGENISMO.',
                        'NASO: RINOSETTOPLASTOCA. RIDUZIONE FRATTURA OSSA NASALI. ANTROSTOMIA MASCELLARE.',
                        'ORBITA: EXENTERATIO ORBITALE. RIDUZIONE FRATTURA ORBITARIA TRAUMATICA E ATRAUMATICA.',
                        'COLLO: PAROTIDECTOMIA. CERVICOTOMIA. SVUOTAMENTO LATERO-CERVICALE. TRACHEOTOMIA.',
                        'LEMBO: RESEZIONE MANDIBOLARE E GLOSSECTOMIA CON RICOSTRUZIONE LEMBO LIBERO E PEDUNCOLATO CON OSSO AUTOLOGO.'
                    ]
                }

            ],
            "Day Surgery Oculistica": [
                {
                    key: 'Cataratta',
                    questions: [
                        '13.72 - IMPIANTO SECONDARIO DI CRISTALLINO ARTIFICIALE',
                        '13.41_2 - INTERVENTO DI CATARATTA CON O SENZA IMPIANTO DI LENTE INTRAOCULARE - OCCHIO DX',
                        '13.72_3 - IMPIANTO SECONDARIO DI CRISTALLINO ARTIFICIALE - OCCHIO SX',
                        '13.2 - ESTRAZIONE EXTRACAPSULARE DELLA CATARATTA CON TECNICA DI ESTRAZIONE LINEARE',
                        '13.72 - IMPIANTO SECONDARIO DI CRISTALLINO ARTIFICIALE'
                    ]
                },
                {
                    key: 'Vitreo retina',
                    questions: [
                        '14.72 - ALTRA RIMOZIONE DEL CORPO VITREO',
                        '14.41 - PIOMBAGGIO SCLERALE CON IMPIANTO',
                        '14.74 - ALTRA VITRECTOMIA MECCANICA',
                        '14.75 - INIEZIONE DI SOSTITUTI VITREALI'
                    ]
                },
                {
                    key: 'Glaucoma',
                    questions: [
                        '12.69 - ALTRI INTERVENTI DI FISTOLIZZAZIONE DELLA SCLERA',
                        '12.89 - ALTRI INTERVENTI SULLA SCLERA',
                        '12.64 - TRABECULECTOMIA AB EXTERNO',
                        '12.83 - REVISIONE DI FERITA OPERATORIA DEL SEGMENTO ANTERIORE DELL/OCCHIO NON CLASSIFICATA ALTROVE'

                    ]
                },
                {
                    key: 'Palpebra',
                    questions: [
                        '08.24 - ASPORTAZIONE DI LESIONE ESTESA DELLA PALPEBRA, A TUTTO SPESSORE',
                        '08.23 - ASPORTAZIONE DI LESIONE ESTESA DELLA PALPEBRA NON A TUTTO SPESSORE',
                        '08.33 - CORREZIONE DI BLEFAROPTOSI CON RESEZIONE O AVANZAMENTO DEL MUSCOLO ELEVATORE O SUA APONEUROSI'

                    ]
                },
                {
                    key: 'Cornea',
                    questions: [
                        '11.60 - TRAPIANTO DI CORNEA, NON ALTRIMENTI SPECIFICATO',
                        '11.64 - ALTRA CHERATOPLASTICA PERFORANTE OMOLOGA',
                        '11.69 - ALTRO TRAPIANTO DELLA CORNEA',
                        '11.39 - ALTRA ASPORTAZIONE DELLO PTERIGIUM'

                    ]
                },
                {
                    key: 'Orbita e Congiuntiva',
                    questions: [
                        '16.42 - ENUCLEAZIONE DEL BULBO OCULARE CON ALTRO IMPIANTO CONTEMPORANEO',
                        '15.3 - INTERVENTI SU DUE O PIÙ MUSCOLI EXTRAOCULARI CHE RICHIEDONO DISTACCO TEMPORANEO DAL BULBO, UNO O ENTRAMBI GLI OCCHI',
                        '15.11 - ARRETRAMENTO DI UN MUSCOLO EXTRAOCULARE',
                        '10.21_2 - BIOPSIA DELLA CONGIUNTIVA - OCCHIO DX',
                        '10.32 - DEMOLIZIONE DI LESIONE DELLA CONGIUNTIVA',
                        '15.3 - INTERVENTI SU DUE O PIÙ MUSCOLI EXTRAOCULARI CHE RICHIEDONO DISTACCO TEMPORANEO DAL BULBO, UNO O ENTRAMBI GLI OCCHI',
                        '16.22 - ASPIRAZIONE DIAGNOSTICA DELL/ORBITA',
                        '12.89 - ALTRI INTERVENTI SULLA SCLERA',
                        '10.32 - DEMOLIZIONE DI LESIONE DELLA CONGIUNTIVA',
                        '10.21_3 - BIOPSIA DELLA CONGIUNTIVA - OCCHIO SX',
                        '12.89 - ALTRI INTERVENTI SULLA SCLERA'

                    ]
                }
            ]

        };

        // Calcola il punteggio massimo per ogni reparto
        const MAX_SCORES = {};
        for (const reparto in COMPETENCE_DATA) {
            let totalQuestions = 0;
            COMPETENCE_DATA[reparto].forEach(area => {
                totalQuestions += area.questions.length;
            });
            MAX_SCORES[reparto] = totalQuestions * 4; // Max score è 4 per domanda
        }

        const ALL_REPARTI = Object.keys(COMPETENCE_DATA);
        const data = loadData();
        let currentReparto = ALL_REPARTI[0] || 'Chirurgia Generale'; // Default al primo reparto
        let selectedNurseId = null;
        let isEditing = false;

        // Funzione per ottenere le competenze correnti
        function getCurrentCompetences() {
            return COMPETENCE_DATA[currentReparto] || [];
        }

        // Funzione per ottenere il punteggio massimo corrente
        function getCurrentMaxScore() {
            return MAX_SCORES[currentReparto] || 4;
        }

        function saveData() { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); }

        function loadData() {
            const raw = localStorage.getItem(STORAGE_KEY);
            const loaded = raw ? JSON.parse(raw) : {};

            // Inizializza i dati per tutti i reparti se non esistono
            ALL_REPARTI.forEach(reparto => {
                if (!loaded[reparto]) {
                    loaded[reparto] = {
                        infermieri: [],
                        competenze: COMPETENCE_DATA[reparto].map(area => ({
                            title: area.key,
                            items: area.questions.map(q => ({ text: q, values: [1, 2, 3, 4] }))
                        }))
                    };
                }
            });
            return loaded;
        }


        // ---------- Elements ----------
        const nursesList = document.getElementById('nursesList');
        const nurseCard = document.getElementById('nurseCard');
        const competenceContainer = document.getElementById('competenceContainer');
        const summaryScore = document.getElementById('summaryScore');
        const summaryLevel = document.getElementById('summaryLevel');
        const currentRepartoEl = document.getElementById('currentReparto');
        const radarCtx = document.getElementById('radarChart').getContext('2d');
        let radarChart = null;

        // Modal elements
        const modalNurse = document.getElementById('modalNurse');
        const modalTitle = document.getElementById('modalTitle');
        const inputNome = document.getElementById('inputNome');
        const inputCognome = document.getElementById('inputCognome');
        const inputEsperienza = document.getElementById('inputEsperienza');
        const inputMatricola = document.getElementById('inputMatricola');
        const inputRuolo = document.getElementById('inputRuolo');
        const inputValutatore = document.getElementById('inputValutatore');
        const inputReparto = document.getElementById('inputReparto');


        // ---------- Rendering ----------
        function renderNurses() {
            nursesList.innerHTML = '';
            // Filtra gli infermieri in base al reparto corrente
            const list = (data[currentReparto] && data[currentReparto].infermieri) || [];

            if (list.length === 0) { nursesList.innerHTML = `<div class="text-sm text-gray-500">Nessun infermiere trovato nel reparto ${currentReparto}.</div>`; }
            list.forEach(n => {
                const card = document.createElement('div');
                const selectedClass = n.id === selectedNurseId ? 'bg-blue-200 dark:bg-blue-600' : 'bg-gray-50 dark:bg-gray-700';
                card.className = `p-3 ${selectedClass} rounded shadow-sm hover:scale-[1.01] transition-transform cursor-pointer`;
                card.innerHTML = `<div class='font-semibold'>${n.nome} ${n.cognome}</div><div class='text-xs text-gray-500'>${n.ruolo || ''} ${n.matricola ? ' - ' + n.matricola : ''}</div>`;
                card.addEventListener('click', () => selectNurse(n.id));
                nursesList.appendChild(card);
            });
        }

        // Funzione di rendering delle competenze con switch (già ottimizzata)
        function renderCompetences() {
            competenceContainer.innerHTML = '';
            const comps = getCurrentCompetences().map(area => ({
                title: area.key,
                items: area.questions.map(q => ({ text: q, values: [1, 2, 3, 4] }))
            }));

            comps.forEach((sec, sIdx) => {
                const uniqueId = `sec_${currentReparto.replace(/\s/g, '_')}_${sIdx}`;
                const secWrap = document.createElement('div');
                secWrap.className = 'border rounded p-3 bg-white/50 dark:bg-gray-800 transition-all';

                // Header con Titolo e Toggle
                const header = document.createElement('div');
                header.className = 'flex items-center justify-between cursor-pointer';
                header.innerHTML = `
                                <h4 class='font-semibold'>${sec.title}</h4>
                                <label class="flex items-center cursor-pointer">
                                    <div class="relative">
                                        <input type="checkbox" id="${uniqueId}_toggle" class="sr-only competence-toggle">
                                        <div class="block bg-gray-600 w-10 h-6 rounded-full"></div>
                                        <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition"></div>
                                    </div>
                                </label>
                            `;

                // Contenitore delle domande (inizialmente nascosto e disattivato)
                const list = document.createElement('div');
                list.className = 'mt-4 space-y-4 hidden competence-list';
                list.id = `${uniqueId}_list`;

                sec.items.forEach((it, iIdx) => {
                    const questionDiv = document.createElement('div');
                    questionDiv.className = 'border-b pb-2';
                    questionDiv.innerHTML = `<p class='font-medium text-sm mb-2'>${it.text}</p>`;

                    const radioGroup = document.createElement('div');
                    radioGroup.className = 'flex gap-4 justify-between text-xs';

                    it.values.forEach(val => {
                        const radioId = `r_${currentReparto.replace(/\s/g, '_')}_${sIdx}_${iIdx}_${val}`;
                        const radioName = `radio_${currentReparto.replace(/\s/g, '_')}_${sIdx}_${iIdx}`;

                        const label = document.createElement('label');
                        label.className = 'flex items-center gap-1 cursor-pointer';
                        label.innerHTML = `
                                                <input type='radio' id='${radioId}' name='${radioName}' data-section='${sIdx}' data-item='${iIdx}' data-value='${val}' class='competenza-radio' disabled>
                                                <span>${val}</span>
                                            `;
                        radioGroup.appendChild(label);
                    });

                    questionDiv.appendChild(radioGroup);
                    list.appendChild(questionDiv);
                });

                secWrap.appendChild(header);
                secWrap.appendChild(list);
                competenceContainer.appendChild(secWrap);

                // Aggiungi listener per il toggle
                const toggleInput = document.getElementById(`${uniqueId}_toggle`);
                const radioInputs = list.querySelectorAll('.competenza-radio');

                toggleInput.addEventListener('change', (e) => {
                    const isChecked = e.target.checked;
                    list.classList.toggle('hidden', !isChecked);
                    secWrap.classList.toggle('bg-white/50', !isChecked);
                    secWrap.classList.toggle('bg-blue-50/70', isChecked); // Colore di sfondo per competenza attiva

                    // Abilita/Disabilita i radio button e rimuovi selezione se disattivato
                    radioInputs.forEach(radio => {
                        radio.disabled = !isChecked;
                        if (!isChecked) {
                            radio.checked = false; // Rimuove la selezione se disattivato
                        }
                    });
                    updateScores(); // Aggiorna i punteggi dopo l'attivazione/disattivazione
                });
            });
            // bind change per tutti i radio button
            document.querySelectorAll('.competenza-radio').forEach(rb => rb.addEventListener('change', updateScores));
        }

        function updateNurseCard() {
            if (!selectedNurseId) { nurseCard.innerHTML = 'Nessun infermiere selezionato'; document.getElementById('btnEditNurse').classList.add('hidden'); document.getElementById('btnDeleteNurse').classList.add('hidden'); return; }
            // Cerca l'infermiere nel reparto corrente
            const n = data[currentReparto].infermieri.find(x => x.id === selectedNurseId);
            if (!n) return;
            nurseCard.innerHTML = `
                                        <div class='font-medium text-lg'>${n.nome} ${n.cognome}</div>
                                        <div class='text-sm text-gray-600'>${n.ruolo || '-'} | Matricola: ${n.matricola || '-'}</div>
                                        <div class='text-sm mt-2'>Esperienza: ${n.esperienza || '-'} anni</div>
                                        <div class='text-sm mt-2 text-gray-500'>Ultima valutazione: ${n.ultimaValutazione && n.ultimaValutazione.reparto === currentReparto ? n.ultimaValutazione.data : 'Mai (o in altro reparto)'}</div>`;
            document.getElementById('btnEditNurse').classList.remove('hidden'); document.getElementById('btnDeleteNurse').classList.remove('hidden');
        }

        // Funzione per selezionare il reparto e ricaricare tutti gli elementi
        function selectReparto(name, isInitial = false) {
            currentReparto = name;
            currentRepartoEl.textContent = name;

            // Gestisce l'evidenziazione del pulsante cliccato
            document.querySelectorAll('.reparto-btn').forEach(b => {
                b.classList.remove('bg-blue-100', 'dark:bg-blue-900');
                if (b.dataset.reparto === name) {
                    b.classList.add('bg-blue-100', 'dark:bg-blue-900');
                }
            });

            // Resetta la selezione infermiere e aggiorna la UI
            selectedNurseId = null;
            updateNurseCard();
            renderNurses();
            renderCompetences();
            resetScores();
        }

        function selectNurse(id) {
            selectedNurseId = id;
            updateNurseCard();
            loadNurseEvaluation();
            renderNurses();
        }

        // Funzione per aprire il modal infermiere (Riferimenti a 'classe' e 'classeManuale' rimossi)
        function openNurseModal(edit = false) {
            isEditing = edit;
            modalNurse.classList.remove('hidden'); modalNurse.classList.add('flex');
            if (edit && selectedNurseId) {
                const n = data[currentReparto].infermieri.find(x => x.id === selectedNurseId);
                modalTitle.textContent = 'Modifica infermiere'; inputNome.value = n.nome; inputCognome.value = n.cognome; inputEsperienza.value = n.esperienza || '';
                inputMatricola.value = n.matricola || ''; inputRuolo.value = n.ruolo || ''; inputValutatore.value = n.valutatore || ''; inputReparto.value = n.reparto || currentReparto;
                // Rimosso riferimento a n.classeManuale
            } else {
                modalTitle.textContent = 'Aggiungi infermiere'; inputNome.value = ''; inputCognome.value = ''; inputEsperienza.value = ''; inputMatricola.value = ''; inputRuolo.value = ''; inputValutatore.value = ''; inputReparto.value = currentReparto;
                // Rimosso riferimento a document.getElementById('classe').value
            }
        }
        function closeNurseModal() { modalNurse.classList.add('hidden'); modalNurse.classList.remove('flex'); }

        // ---------- Actions ----------
        document.getElementById('btnAddNurseLeft').addEventListener('click', () => openNurseModal(false));
        document.getElementById('btnEditNurse').addEventListener('click', () => {
            if (!selectedNurseId) { alert('Seleziona un infermiere'); return; } openNurseModal(true);
        });
        document.getElementById('modalCancel').addEventListener('click', closeNurseModal);

        // Funzione di salvataggio modal (Riferimenti a 'classe' e 'classeManuale' rimossi)
        document.getElementById('modalSave').addEventListener('click', () => {
            const nome = inputNome.value.trim(); const cognome = inputCognome.value.trim();
            if (!nome || !cognome) { alert('Nome e cognome obbligatori'); return; }
            const repartoValue = inputReparto.value.trim() || currentReparto;
            // Rimosso: const classeSelezionata = document.getElementById('classe').value;

            // Logica di salvataggio: l'infermiere viene salvato nel reparto indicato nel modal/o corrente
            if (!data[repartoValue]) {
                data[repartoValue] = { infermieri: [], competenze: COMPETENCE_DATA[repartoValue] ? COMPETENCE_DATA[repartoValue].map(area => ({ title: area.key, items: area.questions.map(q => ({ text: q, values: [1, 2, 3, 4] })) })) : { infermieri: [] } };
            }

            if (isEditing && selectedNurseId) {
                // Rimuovi dal vecchio reparto e aggiungi al nuovo, se il reparto è cambiato
                const oldReparto = data[currentReparto].infermieri.find(x => x.id === selectedNurseId)?.reparto || currentReparto;
                if (oldReparto !== repartoValue) {
                    data[oldReparto].infermieri = data[oldReparto].infermieri.filter(x => x.id !== selectedNurseId);
                }

                const infermieriList = data[repartoValue].infermieri;
                let idx = infermieriList.findIndex(x => x.id === selectedNurseId);

                if (idx !== -1) {
                    const updated = {
                        ...infermieriList[idx],
                        nome, cognome, esperienza: inputEsperienza.value, matricola: inputMatricola.value,
                        ruolo: inputRuolo.value, valutatore: inputValutatore.value,
                        reparto: repartoValue,
                        // classeManuale Rimosso
                    };
                    infermieriList[idx] = updated;
                } else {
                    // Se l'infermiere non esiste nel nuovo reparto, ricrealo (caso di cambio reparto)
                    const n = { id: selectedNurseId, nome, cognome, esperienza: inputEsperienza.value, matricola: inputMatricola.value, ruolo: inputRuolo.value, valutatore: inputValutatore.value, reparto: repartoValue, valutazioni: [], ultimaValutazione: null }; // classeManuale Rimosso
                    infermieriList.push(n);
                }

                saveData();
                selectReparto(currentReparto); // Ricarica il reparto corrente
                selectNurse(selectedNurseId); // Ricarica l'infermiere selezionato
                closeNurseModal();

            } else {
                const newN = {
                    id: uid(), nome, cognome, esperienza: inputEsperienza.value, matricola: inputMatricola.value,
                    ruolo: inputRuolo.value, valutatore: inputValutatore.value, reparto: repartoValue,
                    // classeManuale Rimosso
                    valutazioni: [], ultimaValutazione: null
                };
                data[repartoValue].infermieri.push(newN);
                saveData();
                selectReparto(repartoValue); // Seleziona il reparto appena aggiunto
                selectNurse(newN.id);
                closeNurseModal();
            }
        });

        document.getElementById('btnDeleteNurse').addEventListener('click', () => {
            if (!selectedNurseId) return; if (!confirm('Confermi eliminazione infermiere?')) return;
            data[currentReparto].infermieri = data[currentReparto].infermieri.filter(x => x.id !== selectedNurseId); selectedNurseId = null; saveData(); renderNurses(); updateNurseCard(); resetScores();
        });

        document.getElementById('btnStart').addEventListener('click', () => {
            if (!selectedNurseId) { alert('Seleziona un infermiere prima di iniziare'); return; }
            competenceContainer.classList.remove('opacity-50'); competenceContainer.classList.remove('pointer-events-none'); document.getElementById('instructions').textContent = 'Compila le competenze selezionando un livello (1-4) per ogni domanda.';
        });

        // Funzione di salvataggio valutazione (già ottimizzata per i toggle)
        document.getElementById('btnSaveEval').addEventListener('click', () => {
            if (!selectedNurseId) { alert('Seleziona infermiere'); return; }

            const { scores, sectionDetails } = computeSectionScores();
            const total = scores.reduce((a, b) => a + b, 0);

            const nurse = data[currentReparto].infermieri.find(x => x.id === selectedNurseId);

            // Controlla che le sezioni ATTIVATE siano tutte risposte
            const missingResponses = sectionDetails.filter(d => {
                const toggleId = `sec_${currentReparto.replace(/\s/g, '_')}_${sectionDetails.findIndex(s => s.key === d.key)}_toggle`;
                const isSectionActive = document.getElementById(toggleId)?.checked || false;
                return isSectionActive && d.answeredCount < d.questionsCount;
            });

            if (missingResponses.length > 0) {
                alert(`Attenzione: devi rispondere a TUTTE le domande nelle sezioni attivate.`);
                return;
            }

            // Prepara i dati della valutazione
            const selectedRadios = Array.from(document.querySelectorAll('.competenza-radio:checked')).map(rb => ({
                sectionIndex: rb.dataset.section,
                itemIndex: rb.dataset.item,
                value: Number(rb.dataset.value)
            }));

            // Salva lo stato dei toggle attivati
            const activeToggles = Array.from(document.querySelectorAll('.competence-toggle:checked')).map(toggle => toggle.id);


            const valutazione = {
                data: (new Date()).toLocaleString(),
                reparto: currentReparto,
                sections: sectionDetails, // Salva il dettaglio delle sezioni
                total,
                selections: selectedRadios,
                activeToggles: activeToggles // Salva lo stato dei toggle
            };

            nurse.valutazioni = nurse.valutazioni || [];
            // Filtra la valutazione precedente se esiste e sostituisci (per tenere solo l'ultima)
            const otherValuations = nurse.valutazioni.filter(v => v.reparto !== currentReparto);
            nurse.valutazioni = [...otherValuations, valutazione];


            // Salva l'ultima valutazione (sostituisce quella precedente per il reparto corrente)
            nurse.ultimaValutazione = valutazione;

            saveData();
            updateNurseCard();
            alert(`Valutazione salvata. I dati sono pronti per report.html.`);
        });

        // Export e Clear (omessi per brevità, sono gli stessi)
        document.getElementById('btnExportAll').addEventListener('click', () => {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'valutazioni_all.json'; a.click(); URL.revokeObjectURL(url);
        });

        document.getElementById('btnExportJSON').addEventListener('click', () => {
            if (!selectedNurseId) { alert('Seleziona infermiere'); return; }
            const nurse = data[currentReparto].infermieri.find(x => x.id === selectedNurseId); const blob = new Blob([JSON.stringify({ nurse, reparto: currentReparto }, null, 2)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `${nurse.nome}_${nurse.cognome}_valutazione.json`; a.click(); URL.revokeObjectURL(url);
        });

        document.getElementById('btnClearAll').addEventListener('click', () => {
            if (!confirm('Svuotare solo le valutazioni (gli infermieri resteranno)?')) return;

            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) return;
            const allData = JSON.parse(raw);

            // Cancella solo le valutazioni e lascia gli infermieri intatti
            for (const reparto in allData) {
                if (allData[reparto] && Array.isArray(allData[reparto].infermieri)) {
                    allData[reparto].infermieri.forEach(n => {
                        n.valutazioni = [];
                        n.ultimaValutazione = null;
                    });
                }
            }

            localStorage.setItem(STORAGE_KEY, JSON.stringify(allData));
            alert('Valutazioni cancellate. Elenco infermieri conservato.');
            location.reload();
        });

        // Calcolo punteggi per sezione (già ottimizzata)
        // Funzione per calcolare i punteggi per sezione e item
        function computeSectionScores() {
            const comps = COMPETENCE_DATA[currentReparto] || [];
            const scores = [];
            const sectionDetails = [];
            const itemDetails = []; // Nuovo array per i dettagli delle singole domande

            comps.forEach((s, sIdx) => {
                let sum = 0;
                let answeredQuestions = 0;
                const radioGroupNamePrefix = `radio_${currentReparto.replace(/\s/g, '_')}_${sIdx}_`;
                const toggleId = `sec_${currentReparto.replace(/\s/g, '_')}_${sIdx}_toggle`;
                const isSectionActive = document.getElementById(toggleId)?.checked || false;

                const currentSectionItems = []; // Dettagli item per la sezione corrente

                s.questions.forEach((item, iIdx) => {
                    const radioName = `${radioGroupNamePrefix}${iIdx}`;
                    const selectedRadio = document.querySelector(`input[name='${radioName}']:checked`);
                    let value = 0;
                    let levelText = 'Non risposto';

                    if (isSectionActive && selectedRadio) {
                        value = Number(selectedRadio.dataset.value || 0);
                        sum += value;
                        answeredQuestions++;
                        // Il livello per item è la mappatura diretta del punteggio (1: diretta, 2: indiretta, etc.)
                        levelText = scoreToLevelText(value);
                    } else if (!isSectionActive) {
                        levelText = 'Non Valutato';
                    }

                    currentSectionItems.push({
                        question: item,
                        score: value,
                        level: levelText
                    });
                });

                itemDetails.push({ key: s.key, questions: currentSectionItems }); // Salva i dettagli di tutti gli item della sezione

                const totalQuestions = s.questions.length;
                // Calcolo della media solo se la sezione è attiva
                const averageScore = isSectionActive && answeredQuestions > 0 ? sum / answeredQuestions : 0;

                // Livello riassuntivo del gruppo (solo se ci sono risposte valide)
                const groupLevelText = isSectionActive && answeredQuestions > 0 ? scoreToLevelText(averageScore) : (isSectionActive ? 'Non Completo' : 'Non Valutato');

                scores.push(sum);
                sectionDetails.push({
                    key: s.key,
                    score: sum,
                    level: groupLevelText,
                    questionsCount: totalQuestions,
                    answeredCount: answeredQuestions,
                    average: averageScore
                });
            });
            return { scores, sectionDetails, itemDetails }; // Restituisce i dettagli degli item
        }

        // Aggiornamento UI punteggi e livelli (già ottimizzata)
        // Funzione per aggiornare il riepilogo
        function updateScores() {
            // La funzione computeSectionScores() è fondamentale: ci fornisce i dati grezzi.
            // L'array 'sectionDetails' è usato per il grafico e i totali.
            const { scores, sectionDetails, itemDetails, sections: sectionAggregates, selections: selectionDetails } = computeSectionScores();

            // Calcolo del punteggio totale (media delle medie per sezione)
            const total = scores.reduce((a, b) => a + b, 0);
            const overallAverage = scores.length > 0 ? total / scores.length : 0;

            const totalMaxScore = getCurrentMaxScore();

            // Aggiornamento UI
            summaryScore.textContent = `Punteggio totale: ${overallAverage.toFixed(2)} (Max teorico: ${totalMaxScore})`;

            // Costruisce il riepilogo dettagliato per ogni item attivo
            let summaryHtml = '';

            itemDetails.forEach((section, sIdx) => {
                const toggleId = `sec_${currentReparto.replace(/\s/g, '_')}_${sIdx}_toggle`;
                const isSectionActive = document.getElementById(toggleId)?.checked || false;

                // Mostra solo le competenze attive e con almeno una risposta
                const answeredItems = section.questions.filter(item => item.score > 0);
                if (!isSectionActive || answeredItems.length === 0) return;

                summaryHtml += `<h4 class='font-semibold mt-4 mb-1 text-blue-700 dark:text-blue-300'>${section.key}</h4>`;

                answeredItems.forEach(item => {
                    const color = item.score >= 3
                        ? 'text-green-600 dark:text-green-400'
                        : 'text-blue-600 dark:text-blue-400';

                    summaryHtml += `
                <div class="flex flex-col space-y-0">
                    <span class="text-xs text-gray-700 dark:text-gray-300">${item.question}</span>
                    <span class="${color} text-sm font-semibold ml-2">${item.level}</span>
                </div>`;
                });
            });

            // ====================================================================
            // 🛑 ASSEGNAZIONE DELLE VARIABILI GLOBALI (NUOVO FIX PER INPUT)
            // ====================================================================

            // 1. Rileva i dati dell'Infermiere dagli INPUT
            const inputMatricola = document.getElementById('inputMatricola');
            const inputNome = document.getElementById('inputNome');
            const inputCognome = document.getElementById('inputCognome');
            const inputValutatore = document.getElementById('inputValutatore'); // Già usato per il valutatore

            const matricolaValue = inputMatricola?.value || '';
            const nomeValue = inputNome?.value || '';
            const cognomeValue = inputCognome?.value || '';
            const valutatoreValue = inputValutatore?.value || '-';

            let nurseData = null;

            // La validazione ora si basa sulla presenza della Matricola (l'ID univoco)
            if (matricolaValue.trim() !== '') {
                // Se la matricola è presente, creiamo l'oggetto nurseData
                nurseData = {
                    id: matricolaValue, // La Matricola è l'ID
                    nome: nomeValue || "N/D",
                    cognome: cognomeValue || "N/D",
                    matricola: matricolaValue,
                    valutatore: valutatoreValue
                };
            }

            // 🛑 DEBUG: Controlla ora cosa è stato letto dagli input
            console.log("DEBUG INFERMIERE: Dati letti dagli input. Matricola:", matricolaValue, "Infermiere letto:", !!nurseData);

            // 2. Assegna i dati alle variabili globali (window.*) che il salvataggio legge
            window.currentNurse = nurseData;
            window.totalScore = overallAverage; // Assegna il punteggio
            window.sections = sectionDetails;

            // Costruisce l'array 'selections' richiesto dal report.html
            window.selections = itemDetails.flatMap(section =>
                section.questions.filter(item => item.score > 0).map(item => ({
                    value: item.score,
                    sectionIndex: section.sectionIndex,
                    itemIndex: item.itemIndex
                }))
            );

            console.log("✅ Dati globali aggiornati. Punteggio:", window.totalScore.toFixed(2));

            // ====================================================================
            // 🎨 AGGIORNAMENTO UI (SPOSTATO ALL'INTERNO DELLA FUNZIONE)
            // ====================================================================

            summaryLevel.innerHTML =
                summaryHtml.trim() === ''
                    ? `<p class='text-sm text-gray-500 italic'>Nessuna competenza valutata.</p>`
                    : `<h4 class='font-semibold mb-2'>Livelli di Riferimento Dettagliati:</h4><div class='space-y-3 text-sm'>${summaryHtml}</div>`;

            // Aggiorna il grafico radar
            const labels = getCurrentCompetences().map(s => s.key);

            if (radarChart) radarChart.destroy();

            const dataForRadar = sectionDetails.map(d => d.average);
            const maxRadar = 4;

            radarChart = new Chart(radarCtx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Livello Medio',
                        data: dataForRadar,
                        backgroundColor: 'rgba(59,130,246,0.18)',
                        borderColor: '#3b82f6',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: { r: { beginAtZero: true, max: maxRadar } }
                }
            });
        }

        // Funzione di reset punteggi (già ottimizzata)
        function resetScores() {
            document.querySelectorAll('.competenza-radio').forEach(rb => rb.checked = false);
            document.querySelectorAll('.competence-toggle').forEach(toggle => {
                toggle.checked = false;
                toggle.dispatchEvent(new Event('change')); // Simula il click per disattivare e nascondere
            });

            updateScores();
            document.getElementById('instructions').textContent = 'Premi Inizia valutazione per abilitare le sezioni.';
            competenceContainer.classList.add('opacity-50');
            competenceContainer.classList.add('pointer-events-none');
        }

        // Funzione di caricamento valutazione (già ottimizzata)
        function loadNurseEvaluation() {
            renderCompetences();
            const nurse = data[currentReparto].infermieri.find(x => x.id === selectedNurseId);

            if (!nurse) {
                resetScores();
                return;
            }

            const lastEval = nurse.valutazioni ? nurse.valutazioni.find(v => v.reparto === currentReparto) : null;

            if (!lastEval || !lastEval.selections) {
                resetScores();
                return;
            }

            // 1. Ripristina lo stato dei toggle
            document.querySelectorAll('.competence-toggle').forEach(toggle => {
                const isChecked = lastEval.activeToggles?.includes(toggle.id) || false;
                toggle.checked = isChecked;

                // Attiva la logica di visualizzazione/disattivazione dei radio buttons
                const listId = toggle.id.replace('_toggle', '_list');
                const list = document.getElementById(listId);
                const radioInputs = list.querySelectorAll('.competenza-radio');
                const secWrap = toggle.closest('div.border');

                list.classList.toggle('hidden', !isChecked);
                secWrap.classList.toggle('bg-white/50', !isChecked);
                secWrap.classList.toggle('bg-blue-50/70', isChecked);

                radioInputs.forEach(radio => {
                    radio.disabled = !isChecked;
                });
            });

            // 2. Ripristina le selezioni dei radio button
            const selections = lastEval.selections;
            document.querySelectorAll('.competenza-radio').forEach(rb => rb.checked = false);

            selections.forEach(sel => {
                // ID: r_Reparto_sectionIndex_itemIndex_value
                const id = `r_${currentReparto.replace(/\s/g, '_')}_${sel.sectionIndex}_${sel.itemIndex}_${sel.value}`;
                const rb = document.getElementById(id);
                if (rb) {
                    rb.checked = true;
                }
            });

            updateScores();
            document.getElementById('btnStart').click(); // Abilita l'interfaccia
        }

        // Gestione degli eventi sui pulsanti Reparto
        document.querySelectorAll('.reparto-btn').forEach(btn => btn.addEventListener('click', e => {
            selectReparto(e.currentTarget.dataset.reparto);
        }));


        // Theme toggle
        const themeToggle = document.getElementById('themeToggle');
        themeToggle.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark');
            themeToggle.textContent = document.documentElement.classList.contains('dark') ? '☀️' : '🌙';
        });

        // Init
        function init() {
            const initialReparto = document.querySelector('.reparto-btn').dataset.reparto;
            selectReparto(initialReparto, true);
            renderCompetences();
            renderNurses();
            updateScores();
        }
        init();

        // Reset dati locali da sidebar
        document.getElementById('clearLocal').addEventListener('click', () => {
            if (!confirm('Eliminare tutti i dati salvati localmente?')) return;
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        });

        //link VBHC
        document.getElementById('btnImport').addEventListener('click', () => {
            window.open('survey_vbhc_infermieri_sala_operatoria_html.html', '_blank');
        });</script>

    <script type="module">import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
        import { getFirestore, collection, addDoc } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-analytics.js";

        // 🛑 ASSICURATI DI INSERIRE QUI I TUOI DATI DI CONFIGURAZIONE FIREBASE REALI
        const firebaseConfig = {
            apiKey: "AIzaSyDuDjV6nU5YuNfkivTKJ1kf6NwmkGRIi34",
            authDomain: "clinicalcompetenceor.firebaseapp.com",
            projectId: "clinicalcompetenceor",
            storageBucket: "clinicalcompetenceor.firebasestorage.app",
            messagingSenderId: "91172915109",
            appId: "1:91172915109:web:f548cb1f92fb5ae08f8a4c",
            measurementId: "G-V547BJD3VC"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const analytics = getAnalytics(app);

        // =========================================================================
        // 🛑 FUNZIONE FONDAMENTALE DI CALCOLO E ASSEGNAZIONE DATI (FINAL FIX)
        // =========================================================================

        function aggiornaDatiECalcolaPunteggio() {
            // Questa funzione deve essere chiamata dal codice applicativo ogni volta che un dato viene modificato.

            let totalScore = 0;
            let totalCount = 0;
            const datiDelleSezioni = [];
            const datiDelleSelezioni = []; // Nuovo array per i dettagli richiesti dal report.html

            // -------------------------------------------------------------------------
            // 1. RACCOLTA DATI DAI CAMPI HTML/GLOBALI (CONTROLLA GLI ID)
            // -------------------------------------------------------------------------

            // Legge il Valutatore
            const valutatore = document.getElementById('inputValutatore')?.value || '-';

            // 🚨 Placeholder per l'Infermiere: Se il tuo infermiere viene selezionato da un <select> con ID 'selectInfermiere'
            const infermiereSelect = document.getElementById('selectInfermiere');
            let infermiereDati = null;

            if (infermiereSelect?.value && infermiereSelect.value !== 'null' && infermiereSelect.value !== '') {
                // Assumiamo che il 'value' contenga un ID/matricola e il 'text' il nome
                const selectedOption = infermiereSelect.options[infermiereSelect.selectedIndex];

                // 🚨 ADATTARE QUESTA LOGICA: Se i dati del tuo infermiere sono più complessi (es. nome, cognome, matricola)
                // devi leggere quei dati da dove li hai memorizzati (es. un oggetto globale, un data-attribute, o un JSON)
                infermiereDati = {
                    id: infermiereSelect.value,
                    nome: selectedOption?.text.split(' ')[0] || "N/D", // Placeholder
                    cognome: selectedOption?.text.split(' ').slice(1).join(' ') || "N/D", // Placeholder
                    matricola: infermiereSelect.value, // Usiamo l'ID come matricola per semplicità
                    valutatore: valutatore
                };
            }

            // -------------------------------------------------------------------------
            // 2. LOGICA DI CALCOLO: Aggregazione Punteggi e Dettagli
            // -------------------------------------------------------------------------

            const toggles = document.querySelectorAll('.competence-toggle:checked');
            const sezioniMappa = new Map();

            toggles.forEach(toggle => {
                // Legge il punteggio (value)
                const score = parseFloat(toggle.value) || parseFloat(toggle.dataset.score) || 1;

                // Legge i metadati necessari per il report
                const sectionName = toggle.dataset.section || 'Generica';
                const sectionIndex = parseInt(toggle.dataset.sectionIndex);
                const itemIndex = parseInt(toggle.dataset.itemIndex);

                totalScore += score;
                totalCount++;

                // 2a. Crea l'array 'selections' (dettagli di ogni singola risposta)
                datiDelleSelezioni.push({
                    value: score,
                    sectionIndex: sectionIndex,
                    itemIndex: itemIndex
                });

                // 2b. Aggrega i dati per sezione (per l'array 'sections')
                if (!sezioniMappa.has(sectionName)) {
                    sezioniMappa.set(sectionName, { total: 0, count: 0, answeredCount: 0, sectionIndex: sectionIndex });
                }
                sezioniMappa.get(sectionName).total += score;
                sezioniMappa.get(sectionName).count++;
                sezioniMappa.get(sectionName).answeredCount++; // Conta le risposte
            });

            // 3. Calcola media finale e popola l'array di sezioni
            const punteggioFinale = totalCount > 0 ? totalScore / totalCount : 0;

            sezioniMappa.forEach(data => {
                datiDelleSezioni.push({
                    nome: data.nome,
                    average: data.total / data.count,
                    total: data.total,
                    answeredCount: data.answeredCount,
                    sectionIndex: data.sectionIndex
                });
            });

            // -------------------------------------------------------------------------
            // 4. 🛑 ASSEGNAZIONE A WINDOW (QUESTO RISOLVE L'ERRORE DI SALVATAGGIO)
            // -------------------------------------------------------------------------

            window.currentNurse = infermiereDati;
            window.totalScore = punteggioFinale;
            window.sections = datiDelleSezioni;
            window.selections = datiDelleSelezioni; // Aggiunto per il tuo report.html

            // Debug
            console.log(`✅ Calcolo completato. Punteggio: ${punteggioFinale.toFixed(2)}. Infermiere pronto: ${!!infermiereDati}`);
        }

        // =========================================================================
        // 🛑 REGISTRAZIONE LISTENER (PER ATTIVARE IL CALCOLO)
        // =========================================================================

        window.addEventListener("DOMContentLoaded", () => {
            // Avvia il calcolo iniziale (importante per popolare window all'avvio)
            aggiornaDatiECalcolaPunteggio();

            // Listener per la selezione dell'infermiere (se l'ID è 'selectInfermiere')
            document.getElementById('selectInfermiere')?.addEventListener('change', aggiornaDatiECalcolaPunteggio);

            // Listener per il valutatore (se l'ID è 'inputValutatore')
            document.getElementById('inputValutatore')?.addEventListener('input', aggiornaDatiECalcolaPunteggio);

            // Listener per tutti gli elementi che cambiano il punteggio (toggle, radio, ecc.)
            document.querySelectorAll('.competence-toggle, input[type="radio"]').forEach(element => {
                element.addEventListener('change', aggiornaDatiECalcolaPunteggio);
            });
        });

        // =========================================================================
        // 🔹 LISTENER DI SALVATAGGIO SU FIREBASE (Il tuo blocco originale, con validazione)
        // =========================================================================

        // ... (codice Firebase in cima) ...

        document.getElementById("btnSaveEval").addEventListener("click", async () => {
            // 🛑 1. Forza l'aggiornamento dei dati globali
            if (typeof updateScores === 'function') {
                updateScores();
            }

            // ====================================================================
            // 🛑 LOGICA DI PULIZIA AGGRESSIVA DI undefined (SOLUZIONE FINALE)
            // ====================================================================

            const infermiereData = window.currentNurse || null;

            // Se infermiereData esiste, creiamo una COPIA sicura, altrimenti è null
            const infermiereObj = infermiereData ? {
                // Se un campo interno è undefined, usiamo un fallback
                id: infermiereData.id || "N/D",
                nome: infermiereData.nome || "N/D",
                cognome: infermiereData.cognome || "N/D",
                matricola: infermiereData.matricola || "N/D",
                valutatore: infermiereData.valutatore || "-", // Pulizia aggressiva del valutatore interno
                // NON aggiungere qui altre proprietà che potrebbero essere undefined
            } : null;

            const valutazione = {
                data: new Date().toISOString(),
                reparto: document.getElementById("currentReparto")?.textContent || "N/D",

                // Usiamo l'oggetto pulito: infermiereObj
                infermiere: infermiereObj,

                total: window.totalScore || 0,
                sections: window.sections || [],
                selections: window.selections || [],

                // Il valutatore viene preso dalla COPIA PULITA, o dall'input, o da "-"
                valutatore: infermiereObj?.valutatore || document.getElementById('inputValutatore')?.value || "-",
            };

            console.log("Oggetto 'valutazione' pronto per l'invio:", valutazione);

            // 🛑 2. Controllo di validazione rigoroso
            // Assicuriamo che infermiereObj sia un oggetto valido e abbia un ID valido
            const infermiereIDValido = valutazione.infermiere && valutazione.infermiere.id && valutazione.infermiere.id.trim() !== '' && valutazione.infermiere.id !== 'N/D';
            const punteggioValido = valutazione.total > 0;

            // Log per debug (cosa fallisce esattamente)
            console.log("DEBUG VALIDAZIONE FINALE: Infermiere ID valido:", infermiereIDValido, "Punteggio > 0:", punteggioValido);


            if (!infermiereIDValido || !punteggioValido) {
                console.error("❌ ERRORE CRITICO: Salvataggio annullato per dati incompleti.");
                alert("❌ ERRORE: Assicurati di aver compilato la Matricola e completato la valutazione (punteggio > 0) prima di salvare.");
                return;
            }

            // 🛑 3. Salvataggio su Firebase (solo se la validazione è superata)
            try {
                // ====================================================================
                // 🔥 ULTIMA PULIZIA: Rimuove OGNI 'undefined' residuo (Soluzione definitiva)
                // ====================================================================
                const valutazionePulita = JSON.parse(JSON.stringify(valutazione));

                await addDoc(collection(db, "valutazioni"), valutazionePulita); // Usa la COPIA PULITA
                alert("✅ Valutazione salvata su Firebase! Ricarica la pagina Report per visualizzare.");
            } catch (e) {
                console.error("Errore salvataggio Firebase:", e);
                alert("❌ Errore durante il salvataggio: " + e.message);
            }
        });</script>

</body>
</html>
